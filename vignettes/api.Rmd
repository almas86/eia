---
title: "API details"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{API details}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>", out.width = "100%",
  message = FALSE, warning = FALSE, error = FALSE
)
library(eia)
options(eia_antidos = 0)
key <- Sys.getenv("EIA_KEY")
```

The EIA API can of course impose its own limitations on usage by a given API key. However, `eia` also helps out by limiting the potential for making unnecessary API calls. It does this in two ways, both of which allow optional configuration:

*   caching API results using session-based memoization
*   minimum delay between API calls

By default the `eia` package prevents you from accidentally making too many requests too quickly, but it also offers sensible flexibility.

## Memoization

All functions in `eia` that make API calls use memoization by default. They will not make the same API call twice in one R session. A call is made once and the result is cached. Calling the same function with the identical arguments again will only returned the cached result. 

This approach limits the potential for accidentally using the EIA API more than necessary. This is fine for most uses cases. However, if you use your API key to access data that is updated very often, or you have a long-running R process such as a Shiny app on a server that may need to periodically update the data associated with a specific API call, you can set `cache = FALSE`.

Run this example of the same request made with and without memoization. You will notice the cached result by the immediate return.

```{r memo1, eval=FALSE}
library(eia)
key <- Sys.getenv("EIA_KEY")

system.time(eia_cats(key)) # API call; cache result
system.time(eia_cats(key)) # read from cache
system.time(eia_cats(key, cache = FALSE)) # API call
```

Results are cached in memory for the duration of the R session, but you can clear the cache at any time:

```{r memo2, eval=FALSE}
eia_clear_cache()
system.time(eia_cats(key))
```

This allows you to update the cached result. You can reset the cache for only specific endpoints using the following functions:

*    `eia_clear_cats`
*    `eia_clear_series`
*    `eia_clear_geoset`

## Anti-DOS measures

Regardless of rate overall limiting imposed by the EIA API, the `eia` package sets a minimum wait time of one second between successive API calls. In most cases this is an irrelevant safeguard. Most `eia` functions make a single API call and requests for data often take a full second anyway once you factor in the subsequent data manipulation in R.

However, there are cases where you might want to make multiple calls back to back programmatically and perhaps you are initially unsure how many requests will be made or how quickly these requests may execute. The default minimum wait between API calls is a precaution that helps you be a good neighbor.

You can turn this off with `options` if not needed; for example, a case where you know that your API calls will be small in number and you have no reason to be concerned about exceeding the request limits associated with your API key. The default requires you to make an active decision about how to use the API with your own key and API limits in mind.

A call to `eia_parent_cats` is a good example. This function is recursive, but say you know the number of calls is going to be small; it is overkill to impose the additional wait. Note that in order to show this example, it is necessary to turn off memoization to avoid returned a cached result.

```{r antidos1, echo=FALSE}
options(eia_antidos = 1)
```

```{r antidos2}
system.time(x <- eia_parent_cats(key, 742, cache = FALSE))

options(eia_antidos = 0)
system.time(x <- eia_parent_cats(key, 742, cache = FALSE))

x
```

